input {
  udp {
    port => 5000
    type => syslog
  }
}

filter {
  multiline {
    pattern => "^<%{NUMBER}>%{TIMESTAMP_ISO8601} %{SYSLOGHOST:container_name} %{DATA}(?:\[%{POSINT}\])?:%{SPACE}%{TIMESTAMP_ISO8601}"
    negate => true
    what => "previous"
    stream_identity => "%{container_name}"
  }

  grok {      
    match => [ "message", "(?m)^<%{NUMBER}>%{TIMESTAMP_ISO8601} %{SYSLOGHOST} %{DATA:container_name}(?:\[%{POSINT}\])?:%{SPACE}%{TIMESTAMP_ISO8601:timestamp}%{SPACE}%{LOGLEVEL:loglevel}%{SPACE}%{NUMBER}%{SPACE}---%{SPACE}(?:\[%{DATA:threadname}\])?%{SPACE}%{JAVACLASS:classname}%{SPACE}:%{SPACE}%{GREEDYDATA:logmessage}" ]
  }

  date {
    match => [ "timestamp", "yyyy-MM-dd HH:mm:ss.SSS" ]
    remove_field => ["timestamp"]
  }
  if !("_grokparsefailure" in [tags]) {
    mutate {
      replace => [ "source_host", "%{container_name}" ]
      replace => [ "raw_message", "%{message}" ]
      replace => [ "message", "%{logmessage}" ]
      remove_field => [ "logmessage", "host", "source_host" ]
    }
  }  
  mutate {
    strip => [ "threadname" ]
  }
}

output {
  elasticsearch { }
}